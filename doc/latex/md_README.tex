$\ast$$\ast$fun$\ast$$\ast$ctional programming utilities for P\+HP ! Inspired by {\itshape Ramda}, Javascript, lodash and many other things !

\subsection*{Why ?}


\begin{DoxyItemize}
\item Because P\+HP lacks of simple and easy-\/to-\/use utilities for functional programming !
\item To prove that we can still have fun with P\+HP (despite the fact that it\textquotesingle{}s P\+HP) !!!
\end{DoxyItemize}

\section*{Installation}


\begin{DoxyCode}
composer require boehm\_s/fun
\end{DoxyCode}


\section*{How to use it ?}

You can use it just like Ramda, in fact you can even rely on the excellent \href{https://ramdajs.com/docs/}{\tt Ramda documentation!} !

As with Ramda, fun-\/php methods are automatically curried \+:

{\ttfamily F\+::map(\$fn, \$array)} ~ ⇔ ~ {\ttfamily F\+::map(\$fn)(\$array)} ~ ⇔ ~ {\ttfamily F\+::map()(\$fn)(\$array)}

Also placeholders are implemented. fun-\/php placeholder is {\ttfamily F\+::\+\_\+} \+:

{\ttfamily F\+::map(F\+::\+\_\+, \$array)(\$fn)} ~ ⇔ ~ {\ttfamily F\+::map(\$fn)(F\+::\+\_\+)(\$fn)} ~ ⇔ ~ {\ttfamily F\+::map(\+F\+::\+\_\+)(\$fn)(\$array)}

\subsection*{Example}


\begin{DoxyCode}
\{
  "items": [\{
      "id":1,
      "type":"train",
      "users":[
        \{ "id":1, "name":"Jimmy Page"\},
        \{ "id":5, "name":"Roy Harper"\}
      ]
    \}, \{
      "id":421,
      "type":"hotel",
      "users":[
        \{ "id":1, "name":"Jimmy Page" \}, 
        \{ "id":2, "name":"Robert Plant" \}
      ]
    \}, \{
      "id":876,
      "type":"flight",
      "users":[
        \{ "id":3, "name":"John Paul Jones" \},
        \{ "id":4, "name":"John Bonham" \}
      ]
    \}]
\}
\end{DoxyCode}


Get all users names


\begin{DoxyCode}
$get\_all\_users\_names = F::pipe(
    F::prop(\textcolor{stringliteral}{'items'}),
    F::flatMap(F::prop(\textcolor{stringliteral}{'users'})),
    F::map(F::prop(\textcolor{stringliteral}{'name'})),
    F::uniq()
);

$travel = json\_decode($travelJSON);

$travels\_users = $get\_all\_users\_names($travel);

var\_dump($travels\_users);  \textcolor{comment}{//  ["Jimmy Page", "Roy Harper", "Robert Plant", "John Paul Jones", "John
       Bonham"]}
\end{DoxyCode}


\subsection*{Implemented methods}

{\bfseries fun-\/php} is just a bunch of static methods. To use them, juste prefix the following functions with {\ttfamily F\+:\+:}

\subsubsection*{For Lists / Arrays}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type }&\textbf{ function }&\textbf{ type  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type }&\textbf{ function }&\textbf{ type  }\\\cline{1-4}
\endhead
{\itshape map} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → b) → \mbox{[}a\mbox{]} → \mbox{[}b\mbox{]}} &{\itshape flat\+Map} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → \mbox{[}b\mbox{]}) → \mbox{[}a\mbox{]} → \mbox{[}b\mbox{]}} \\\cline{1-4}
{\itshape filter} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → Bool) → \mbox{[}a\mbox{]} → \mbox{[}a\mbox{]}} &{\itshape reduce} &{\ttfamily ((a, b) → a) → a → \mbox{[}b\mbox{]} → a} \\\cline{1-4}
{\itshape each} &{\ttfamily a → \mbox{[}a\mbox{]} → \mbox{[}a\mbox{]}} &&\\\cline{1-4}
{\itshape find} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → Bool) → \mbox{[}a\mbox{]} → a} &{\itshape find\+Index} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → Bool) → \mbox{[}a\mbox{]} → i} \\\cline{1-4}
{\itshape some} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → Bool) → \mbox{[}a\mbox{]} → Bool} &{\itshape every} &{\ttfamily ((a, i, \mbox{[}a\mbox{]}) → Bool) → \mbox{[}a\mbox{]} → Bool} \\\cline{1-4}
{\itshape sort} &{\ttfamily ((a, a) → Bool) → \mbox{[}a\mbox{]} → \mbox{[}a\mbox{]}} &{\itshape reverse} &{\ttfamily \mbox{[}a\mbox{]} → \mbox{[}a\mbox{]}} \\\cline{1-4}
{\itshape includes} &{\ttfamily a → \mbox{[}a\mbox{]} → Bool} &{\itshape uniq} &{\ttfamily \mbox{[}a\mbox{]} → \mbox{[}a\mbox{]}} \\\cline{1-4}
\end{longtabu}
\subsubsection*{For Objects / Associative arrays}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type }&\textbf{ function }&\textbf{ type  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type }&\textbf{ function }&\textbf{ type  }\\\cline{1-4}
\endhead
{\itshape prop} &{\ttfamily k → \{k\+: v\} → v \textbackslash{}$\vert$ null} &{\itshape pick} &{\ttfamily \mbox{[}k\mbox{]} → \{k\+: v\} → \{k\+: v\} \textbackslash{}$\vert$ null} \\\cline{1-4}
{\itshape prop\+Eq} &{\ttfamily k → v → \{k\+: v\} → Bool} &{\itshape prop\+Satisfies} &{\ttfamily (v → Bool) → k → \{k\+: v\} → Bool} \\\cline{1-4}
{\itshape prop\+Or} &{\ttfamily k → v → \{k\+: v\} → v} &{\itshape merge} &{\ttfamily \{k\+: v\} → (\{k\+: v\}, ..., \{k\+: v\}) → \{k\+: v\}} \\\cline{1-4}
\end{longtabu}
\subsubsection*{For function composition}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type  }\\\cline{1-2}
\endhead
{\itshape compose} &{\ttfamily ((y → z), (x → y), ... ,(a → b)) → (a → z)} \\\cline{1-2}
{\itshape pipe} &{\ttfamily ((a → b), (b → c), ... , (y → z)) → (a → z)} \\\cline{1-2}
{\itshape partial} &{\ttfamily ((a, b, ..., n) → x) → \mbox{[}a, b, ...\mbox{]} → ((d, e, ..., n) → x)} \\\cline{1-2}
\end{longtabu}
\subsubsection*{Logical operations}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ function }&\textbf{ type  }\\\cline{1-2}
\endhead
{\itshape not} &{\ttfamily $\ast$ → Bool} \\\cline{1-2}
\end{longtabu}
